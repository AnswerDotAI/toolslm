# funccall source


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

<details open class="code-fold">
<summary>Exported source</summary>

``` python
import asyncio, inspect, json, ast
from collections import abc
from fastcore.utils import *
from fastcore.docments import docments
from typing import get_origin, get_args, Dict, List, Optional, Tuple, Union, Any
from types import UnionType
from typing import get_type_hints
from inspect import Parameter, Signature
from decimal import Decimal
from uuid import UUID
from functools import reduce
```

</details>

## Function calling

### Function to schema

Many LLMs do function calling (aka tool use) by taking advantage of JSON
schema.

We’ll use [docments](https://fastcore.fast.ai/docments.html) to make
getting JSON schema from Python functions as ergonomic as possible. Each
parameter (and the return value) should have a type, and a docments
comment with the description of what it is. Here’s an example:

``` python
def silly_sum(
    a:int, # First thing to sum
    b:int=1, # Second thing to sum
    c:list[int]=None, # A pointless argument
) -> int: # The sum of the inputs
    "Adds a + b."
    return a + b
```

This is what `docments` makes of that:

``` python
d = docments(silly_sum, full=True)
d
```

``` python
{ 'a': { 'anno': <class 'int'>,
         'default': <class 'inspect._empty'>,
         'docment': 'First thing to sum'},
  'b': {'anno': <class 'int'>, 'default': 1, 'docment': 'Second thing to sum'},
  'c': {'anno': list[int], 'default': None, 'docment': 'A pointless argument'},
  'return': { 'anno': <class 'int'>,
              'default': <class 'inspect._empty'>,
              'docment': 'The sum of the inputs'}}
```

Note that this is an
[AttrDict](https://fastcore.fast.ai/basics.html#attrdict) so we can
treat it like an object, *or* a dict:

``` python
d.a.docment, d['a']['anno']
```

    ('First thing to sum', int)

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _types(t:type)->tuple[str,Optional[str]]:
    "Tuple of json schema type name and (if appropriate) array item name."
    if t is empty: raise TypeError('Missing type')
    tmap = {int:"integer", float:"number", str:"string", bool:"boolean", list:"array", dict:"object"}
    tmap.update({k.__name__: v for k, v in tmap.items()})
    if getattr(t, '__origin__', None) in (list,tuple,set):
        args = getattr(t, '__args__', None)
        item_type = "object" if not args else tmap.get(t.__args__[0].__name__, "object")
        return "array", item_type
    # if t is a string like 'int', directly use the string as the key
    elif isinstance(t, str): return tmap.get(t, "object"), None
    # if t is the type itself and a container
    elif get_origin(t): return tmap.get(get_origin(t).__name__, "object"), None
    # if t is the type itself like int, use the __name__ representation as the key
    else: return tmap.get(t.__name__, "object"), None
```

</details>

This internal function is needed to convert Python types into JSON
schema types.

``` python
_types(list[int]), _types(set[int]), _types(int), _types('int')
```

    (('array', 'integer'),
     ('array', 'integer'),
     ('integer', None),
     ('integer', None))

``` python
_types(List[int]), _types(Optional[str]), _types(str | None), _types(Tuple[str, int])
```

    (('array', 'integer'), ('object', None), ('object', None), ('array', 'string'))

Note the current behavior:

- ignores all but the first argument for tuples
- union types map to object which is a stand-in for arbitrary types

These and other approximations may require further refinement in the
future.

Will also convert custom types to the `object` type.

``` python
class Custom: a: int
_types(list[Custom]), _types(Custom)
```

    (('array', 'object'), ('object', None))

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _param(
    name, # param name
    info, # dict from docments
    evalable=False): # stringify defaults that can't be literal_eval'd?
    "json schema parameter given `name` and `info` from docments full dict"
    paramt,itemt = _types(info.anno)
    pschema = dict(type=paramt, description=info.docment or "")
    if itemt: pschema["items"] = {"type": itemt}
    if info.default is not empty:
        if evalable:
            try: ast.literal_eval(repr(info.default))
            except: pschema["default"] = str(info.default)
            else: pschema["default"] = info.default
        else: pschema["default"] = info.default
    return pschema
```

</details>

This private function converts a key/value pair from the `docments`
structure into the `dict` that will be needed for the schema.

``` python
n,o = first(d.items())
print(n,'//', o)
_param(n, o)
```

    a // {'docment': 'First thing to sum', 'anno': <class 'int'>, 'default': <class 'inspect._empty'>}

    {'type': 'integer', 'description': 'First thing to sum'}

``` python
n,o
```

    ('a',
     {'docment': 'First thing to sum', 'anno': int, 'default': inspect._empty})

``` python
d
```

``` python
{ 'a': { 'anno': <class 'int'>,
         'default': <class 'inspect._empty'>,
         'docment': 'First thing to sum'},
  'b': {'anno': <class 'int'>, 'default': 1, 'docment': 'Second thing to sum'},
  'c': {'anno': list[int], 'default': None, 'docment': 'A pointless argument'},
  'return': { 'anno': <class 'int'>,
              'default': <class 'inspect._empty'>,
              'docment': 'The sum of the inputs'}}
```

``` python
_handle_type(int, None), _handle_type(Path, None)
```

    ({'type': 'integer'}, {'type': 'string', 'format': 'Path'})

``` python
# gemini expect `items` to be defined for arrays
_handle_type(list, None), _handle_type(tuple[str], None), _handle_type(set[str], None)
```

    ({'type': 'array', 'items': {}},
     {'type': 'array', 'items': {}},
     {'type': 'array', 'items': {}})

``` python
_handle_type(dict, None), _handle_type(dict[str,str], None)
```

    ({'type': 'object'}, {'type': 'object'})

``` python
assert _is_parameterized(list[int]) == True
assert _is_parameterized(int) == False
assert _is_container(list[int]) == True
assert _is_container(dict[str, int]) == True
assert _is_container(int) == False
```

For union and optional types, `Union` covers older `Union[str]` syntax
while `UnionType` covers 3.10+ `str | None` syntax.

``` python
def _example_new_unioin(opt_tup: str | None):
    pass

d = docments(_example_new_unioin, full=True)
anno1 = first(d.items())[1].anno
(anno1, get_origin(anno1), get_args(anno1))
```

    (str | None, types.UnionType, (str, NoneType))

``` python
def _example_old_union(opt_tup: Union[str, type(None)] =None):
    pass

d = docments(_example_old_union, full=True)
anno2 = first(d.items())[1].anno
(anno2, get_origin(anno2), get_args(anno2))
```

    (typing.Optional[str], typing.Union, (str, NoneType))

Support for both union types is part of the broader container handling:

``` python
# Test primitive types
defs = {}
assert _handle_type(int, defs) == {'type': 'integer'}
assert _handle_type(str, defs) == {'type': 'string'}
assert _handle_type(bool, defs) == {'type': 'boolean'}
assert _handle_type(float, defs) == {'type': 'number'}

# Test custom class
class TestClass:
    def __init__(self, x: int, y: int): store_attr()

result = _handle_type(TestClass, defs)
assert result == {'$ref': '#/$defs/TestClass'}
assert 'TestClass' in defs
assert defs['TestClass']['type'] == 'object'
assert 'properties' in defs['TestClass']
```

``` python
# Test primitive types in containers
assert _handle_container(list, (int,), defs) == {'type': 'array', 'items': {'type': 'integer'}}
assert _handle_container(tuple, (str,), defs) == {'type': 'array', 'items': {'type': 'string'}}
assert _handle_container(set, (str,), defs) == {'type': 'array', 'items': {'type': 'string'}, 'uniqueItems': True}
assert _handle_container(dict, (str,bool), defs) == {'type': 'object', 'additionalProperties': {'type': 'boolean'}}

result = _handle_container(list, (TestClass,), defs)
assert result == {'type': 'array', 'items': {'$ref': '#/$defs/TestClass'}}
assert 'TestClass' in defs

# Test complex nested structure
ComplexType = dict[str, list[TestClass]]
result = _handle_container(dict, (str, list[TestClass]), defs)
assert result == {
    'type': 'object',
    'additionalProperties': {
        'type': 'array',
        'items': {'$ref': '#/$defs/TestClass'}
    }
}
```

``` python
# Test processing of a required integer property
props, req = {}, {}
class TestClass:
    "Test class"
    def __init__(
        self,
        x: int, # First thing
        y: list[float], # Second thing
        z: str = "default", # Third thing
    ): store_attr()

d = docments(TestClass, full=True)
_process_property('x', d.x, props, req, defs)
assert 'x' in props
assert props['x']['type'] == 'integer'
assert 'x' in req

# Test processing of a required list property
_process_property('y', d.y, props, req, defs)
assert 'y' in props
assert props['y']['type'] == 'array'
assert props['y']['items']['type'] == 'number'
assert 'y' in req

# Test processing of an optional string property with default
_process_property('z', d.z, props, req, defs)
assert 'z' in props
assert props['z']['type'] == 'string'
assert props['z']['default'] == "default"
assert 'z' not in req
```

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L134"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_schema

``` python

def get_schema(
    f:Union, # Function to get schema for
    pname:str='input_schema', # Key name for parameters
    evalable:bool=False, # stringify defaults that can't be literal_eval'd?
    skip_hidden:bool=False, # skip parameters starting with '_'?
    name:NoneType=None, # Override function name (useful for dotted paths like 'obj.method')
)->dict: # {'name':..., 'description':..., pname:...}

```

*Generate JSON schema for a class, function, or method*

``` python
get_schema(get_schema)
```

    {'name': 'get_schema',
     'description': "Generate JSON schema for a class, function, or method\n\nReturns:\n- {'name':..., 'description':..., pname:...} (type: object)",
     'input_schema': {'type': 'object',
      'properties': {'f': {'type': 'object',
        'description': 'Function to get schema for',
        'anyOf': [{'type': 'object'}, {'type': 'object'}]},
       'pname': {'type': 'string',
        'description': 'Key name for parameters',
        'default': 'input_schema'},
       'evalable': {'type': 'boolean',
        'description': "stringify defaults that can't be literal_eval'd?",
        'default': False},
       'skip_hidden': {'type': 'boolean',
        'description': "skip parameters starting with '_'?",
        'default': False},
       'name': {'type': 'null',
        'description': "Override function name (useful for dotted paths like 'obj.method')",
        'default': None}},
      'required': ['f']}}

``` python
def f(o:object): "object function"
```

``` python
get_schema(f)
```

    {'name': 'f',
     'description': 'object function',
     'input_schema': {'type': 'object',
      'properties': {'o': {'type': 'object', 'description': ''}},
      'required': ['o']}}

``` python
class ClassA:
    "I am a class"
    def f(self, a:int): # That is `a`
        "Do a thing"
        return 1
    def __call__(self, b:str): # That is `b`
        "Do another thing"
        return 2

ca = ClassA()
ca.f(2)
```

    1

``` python
get_schema(ca.f)
```

    {'name': 'f',
     'description': 'Do a thing',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'That is `a`'}},
      'required': ['a']}}

``` python
get_schema(ca)
```

    {'name': '__call__',
     'description': 'Do another thing',
     'input_schema': {'type': 'object',
      'properties': {'b': {'type': 'string', 'description': 'That is `b`'}},
      'required': ['b']}}

### Usage examples

Putting this all together, we can now test getting a schema from
`silly_sum`. The tool use spec doesn’t support return annotations
directly, so we put that in the description instead.

``` python
s = get_schema(silly_sum)
desc = s.pop('description')
print(desc)
s
```

    Adds a + b.

    Returns:
    - The sum of the inputs (type: integer)

    {'name': 'silly_sum',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'First thing to sum'},
       'b': {'type': 'integer',
        'description': 'Second thing to sum',
        'default': 1},
       'c': {'type': 'array',
        'description': 'A pointless argument',
        'items': {'type': 'integer'},
        'default': None}},
      'required': ['a']}}

This also works with string annotations, e.g:

``` python
def silly_test(
    a: 'int',  # quoted type hint
)->int:
    "Mandatory docstring"
    return a

get_schema(silly_test)
```

    {'name': 'silly_test',
     'description': 'Mandatory docstring\n\nReturns:\n- type: integer',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'quoted type hint'}},
      'required': ['a']}}

This also works with instance methods:

``` python
class Dummy:
    def sums(
        self,
        a:int,  # First thing to sum
        b:int=1 # Second thing to sum
    ): # The sum of the inputs
        "Adds a + b."
        print(f"Finding the sum of {a} and {b}")
        return a + b

get_schema(Dummy.sums)
```

    {'name': 'sums',
     'description': 'Adds a + b.',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'First thing to sum'},
       'b': {'type': 'integer',
        'description': 'Second thing to sum',
        'default': 1}},
      'required': ['a']}}

[`get_schema`](https://AnswerDotAI.github.io/toolslm/funccall.html#get_schema)
also handles more complicated structures such as nested classes. This is
useful for things like structured outputs.

``` python
class Turn:
    "Turn between two speakers"
    def __init__(
        self,
        speaker_a:str, # First speaker's message
        speaker_b:str,  # Second speaker's message
    ): store_attr()

class Conversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:list[Turn], # Turns of the conversation
    ): store_attr()

get_schema(Conversation)
```

    {'name': 'Conversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'array',
        'description': 'Turns of the conversation',
        'items': {'$ref': '#/$defs/Turn'}}},
      'title': 'Conversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

``` python
class DictConversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:dict[str,list[Turn]], # dictionary of topics and the Turns of the conversation
    ): store_attr()

get_schema(DictConversation)
```

    {'name': 'DictConversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'object',
        'description': 'dictionary of topics and the Turns of the conversation',
        'additionalProperties': {'type': 'array',
         'items': {'$ref': '#/$defs/Turn'}}}},
      'title': 'DictConversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

``` python
class SetConversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:set[Turn], # the unique Turns of the conversation
    ): store_attr()

get_schema(SetConversation)
```

    {'name': 'SetConversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'array',
        'description': 'the unique Turns of the conversation',
        'items': {'$ref': '#/$defs/Turn'},
        'uniqueItems': True}},
      'title': 'SetConversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

### Additional [`get_schema()`](https://AnswerDotAI.github.io/toolslm/funccall.html#get_schema) Test Cases

Union types are approximately mapped to JSON schema ‘anyOf’ with two or
more value types.

``` python
def _union_test(opt_tup: Union[Tuple[int, int], str, int]=None):
    "Mandatory docstring"
    return ""
get_schema(_union_test)
```

    {'name': '_union_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array', 'items': {}},
         {'type': 'string'},
         {'type': 'integer'}]}}}}

The new (Python 3.10+) union syntax can also be used, producing an
equivalent schema.

``` python
def _new_union_test(opt_tup: Tuple[int, int] | str | int =None):
    "Mandatory docstring"
    pass
get_schema(_new_union_test)
```

    {'name': '_new_union_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array', 'items': {}},
         {'type': 'string'},
         {'type': 'integer'}]}}}}

Optional is a special case of union types, limited to two types, one of
which is None (mapped to null in JSON schema):

``` python
def _optional_test(opt_tup: Optional[Tuple[int, int]]=None):
    "Mandatory docstring"
    pass
get_schema(_optional_test)
```

    {'name': '_optional_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array', 'items': {}}, {'type': 'null'}]}}}}

Containers can also be used, both in their parameterized form
(`List[int]`) or as their unparameterized raw type (`List`). In the
latter case, the item type is mapped to `object` in JSON schema.

``` python
def _list_test(l: List[int]):
    "Mandatory docstring"
    pass
get_schema(_list_test)
```

    {'name': '_list_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'l': {'type': 'array',
        'description': '',
        'items': {'type': 'integer'}}},
      'required': ['l']}}

``` python
def _raw_list_test(l: List):
    "Mandatory docstring"
    pass
get_schema(_raw_list_test)
```

    {'name': '_raw_list_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'l': {'type': 'array', 'description': '', 'items': {}}},
      'required': ['l']}}

The same applies to dictionary, which can similarly be parameterized
with key/value types or specified as a raw type.

``` python
def _dict_test(d: Dict[str, int]):
    "Mandatory docstring"
    pass
get_schema(_dict_test)
```

    {'name': '_dict_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'d': {'type': 'object',
        'description': '',
        'additionalProperties': {'type': 'integer'}}},
      'required': ['d']}}

``` python
def _raw_dict_test(d: Dict):
    "Mandatory docstring"
get_schema(_raw_dict_test)
```

    {'name': '_raw_dict_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'d': {'type': 'object', 'description': ''}},
      'required': ['d']}}

``` python
def _path_test(path: Path = Path('.')):
    "Mandatory docstring"
get_schema(_path_test)
```

    {'name': '_path_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'path': {'type': 'string',
        'description': '',
        'default': Path('.'),
        'format': 'Path'}}}}

Schemas that need to be converted using `ast.literal_eval` will fail
with non-primitive defaults:

``` python
test_fail(lambda: ast.literal_eval(str(get_schema(_path_test))), exc=ValueError)
```

Use `evalable` to have those defaults stringified:

``` python
def _path_test(path: Path = Path('.')):
    "Mandatory docstring"
get_schema(_path_test, evalable=True)
```

    {'name': '_path_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'path': {'type': 'string',
        'description': '',
        'default': '.',
        'format': 'Path'}}}}

Use `skip_hidden` to exclude parameters starting with `_` from the
schema:

``` python
def test_hidden(a: int, _internal: str = "x"):
    "Test func"
    pass

get_schema(test_hidden, skip_hidden=True)  # should exclude _internal
```

    {'name': 'test_hidden',
     'description': 'Test func',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': ''}},
      'required': ['a']}}

``` python
get_schema(test_hidden)
```

    {'name': 'test_hidden',
     'description': 'Test func',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': ''},
       '_internal': {'type': 'string', 'description': '', 'default': 'x'}},
      'required': ['a']}}

### Python tool

In language model clients it’s often useful to have a ‘code interpreter’
– this is something that runs code, and generally outputs the result of
the last expression (i.e like IPython or Jupyter).

In this section we’ll create the
[`python`](https://AnswerDotAI.github.io/toolslm/funccall.html#python)
function, which executes a string as Python code, with an optional
timeout. If the last line is an expression, we’ll return that – just
like in IPython or Jupyter, but without needing them installed.

<details open class="code-fold">
<summary>Exported source</summary>

``` python
import ast, time, signal, traceback
from fastcore.utils import *
```

</details>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _copy_loc(new, orig):
    "Copy location information from original node to new node and all children."
    new = ast.copy_location(new, orig)
    for field, o in ast.iter_fields(new):
        if isinstance(o, ast.AST): setattr(new, field, _copy_loc(o, orig))
        elif isinstance(o, list): setattr(new, field, [_copy_loc(value, orig) for value in o])
    return new
```

</details>

This is an internal function that’s needed for
[`_run`](https://AnswerDotAI.github.io/toolslm/funccall.html#_run) to
ensure that location information is available in the abstract syntax
tree (AST), since otherwise python complains.

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _run(code:str, glb:dict=None, loc:dict=None):
    "Run `code`, returning final expression (similar to IPython)"
    tree = ast.parse(code)
    last_node = tree.body[-1] if tree.body else None
    
    # If the last node is an expression, modify the AST to capture the result
    if isinstance(last_node, ast.Expr):
        tgt = [ast.Name(id='_result', ctx=ast.Store())]
        assign_node = ast.Assign(targets=tgt, value=last_node.value)
        tree.body[-1] = _copy_loc(assign_node, last_node)

    compiled_code = compile(tree, filename='<ast>', mode='exec')
    glb = glb or {}
    stdout_buffer = io.StringIO()
    saved_stdout = sys.stdout
    sys.stdout = stdout_buffer
    try: exec(compiled_code, glb, loc)
    finally: sys.stdout = saved_stdout
    _result = glb.get('_result', None)
    if _result is not None: return _result
    return stdout_buffer.getvalue().strip()
```

</details>

This is the internal function used to actually run the code – we pull
off the last AST to see if it’s an expression (i.e something that
returns a value), and if so, we store it to a special `_result` variable
so we can return it.

``` python
_run('import math;math.factorial(12)')
```

    479001600

``` python
_run('print(1+1)')
```

    '2'

We now have the machinery needed to create our
[`python`](https://AnswerDotAI.github.io/toolslm/funccall.html#python)
function.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L197"
target="_blank" style="float:right; font-size:smaller">source</a>

### python

``` python

def python(
    code:str, # Code to execute
    glb:Optional=None, # Globals namespace
    loc:Optional=None, # Locals namespace
    timeout:int=3600, # Maximum run time in seconds
):

```

*Executes python `code` with `timeout` and returning final expression
(similar to IPython).*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def python(
    code:str, # Code to execute
    glb:Optional[dict]=None, # Globals namespace
    loc:Optional[dict]=None, # Locals namespace
    timeout:int=3600 # Maximum run time in seconds
):
    "Executes python `code` with `timeout` and returning final expression (similar to IPython)."
    def handler(*args): raise TimeoutError()
    if glb is None: glb = inspect.currentframe().f_back.f_globals
    if loc is None: loc=glb
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(timeout)
    try: return _run(code, glb, loc)
    except Exception as e: return traceback.format_exc()
    finally: signal.alarm(0)
```

</details>

There’s no builtin security here – you should generally use this in a
sandbox, or alternatively prompt before running code. It can handle
multiline function definitions, and pretty much any other normal Python
syntax.

``` python
python("""def factorial(n):
    if n == 0 or n == 1: return 1
    else: return n * factorial(n-1)
factorial(5)""")
```

    120

If the code takes longer than `timeout` then it returns an error string.

``` python
print(python('import time; time.sleep(10)', timeout=1))
```

    Traceback (most recent call last):
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_37749/2052945749.py", line 14, in python
        try: return _run(code, glb, loc)
                    ^^^^^^^^^^^^^^^^^^^^
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_37749/1858893181.py", line 18, in _run
        try: exec(compiled_code, glb, loc)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      File "<ast>", line 1, in <module>
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_37749/2052945749.py", line 9, in handler
        def handler(*args): raise TimeoutError()
                            ^^^^^^^^^^^^^^^^^^^^
    TimeoutError

By default the caller’s global namespace is used.

``` python
python("a=1")
a
```

    1

Pass a different `glb` if needed; this requires using `python_ns`.

``` python
glb = {}
python("a=3", glb=glb)
a, glb['a']
```

    (1, 3)

``` python
get_schema(python)
```

    {'name': 'python',
     'description': 'Executes python `code` with `timeout` and returning final expression (similar to IPython).',
     'input_schema': {'type': 'object',
      'properties': {'code': {'type': 'string', 'description': 'Code to execute'},
       'glb': {'type': 'object',
        'description': 'Globals namespace',
        'default': None,
        'anyOf': [{'type': 'object'}, {'type': 'null'}]},
       'loc': {'type': 'object',
        'description': 'Locals namespace',
        'default': None,
        'anyOf': [{'type': 'object'}, {'type': 'null'}]},
       'timeout': {'type': 'integer',
        'description': 'Maximum run time in seconds',
        'default': 3600}},
      'required': ['code']}}

### Tool Calling

Many LLM API providers offer tool calling where an LLM can choose to
call a given tool. This is also helpful for structured outputs since the
response from the LLM is contrained to the required arguments of the
tool.

This section will be dedicated to helper functions for calling tools. We
don’t want to allow LLMs to call just any possible function (that would
be a security disaster!) so we create a namespace – that is, a
dictionary of allowable function names to call.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L214"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_ns

``` python

def mk_ns(
    fs
):

```

``` python
def sums(a, b): return a + b
ns = mk_ns(sums); ns
```

    {'sums': <function __main__.sums(a, b)>}

``` python
ns['sums'](1, 2)
```

    3

``` python
ca = ClassA()
```

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L235"
target="_blank" style="float:right; font-size:smaller">source</a>

### resolve_nm

``` python

def resolve_nm(
    nm, ns
):

```

``` python
test_eq(resolve_nm('ca.f', globals()), ca.f)
```

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L240"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_schema_nm

``` python

def get_schema_nm(
    nm:str, ns, dot2dash:bool=False, kwargs:VAR_KEYWORD
):

```

*Get schema for symbol `nm` in namespace `ns`, preserving the full
dotted name*

``` python
schema = get_schema_nm('ca.f', locals())
test_eq(schema['name'], 'ca.f')
schema
```

    {'name': 'ca.f',
     'description': 'Do a thing',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'That is `a`'}},
      'required': ['a']}}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L246"
target="_blank" style="float:right; font-size:smaller">source</a>

### call_func

``` python

def call_func(
    fc_name, fc_inputs, ns, raise_on_err:bool=True
):

```

*Call the function `fc_name` with the given `fc_inputs` using namespace
`ns`.*

Now when we an LLM responses with the tool to use and its inputs, we can
simply use the same namespace it was given to look up the tool and call
it.

``` python
call_func('sums', {'a': 1, 'b': 2}, ns=[sums])
```

    3

``` python
assert "unsupported operand type(s) for +: 'int' and 'str'" in call_func('sums', {'a': 1, 'b': '3'}, ns=ns, raise_on_err=False)
```

``` python
test_fail(call_func, args=['sums', {'a': 1, 'b': '3'}], kwargs={'ns': ns})
```

Types that can be constructed from a plain `str` can be used directly,
as long as they are in `custom_types` (which you can add to).

``` python
def path_test(
    a: Path,  # a type hint
    b: Path   # b type hint
):
    "Mandatory docstring"
    return a/b

test_eq(call_func('path_test', {'a': '/home', 'b': 'user'}, ns=[path_test]), Path('/home/user'))
```

``` python
test_eq(call_func('ca.f', {'a': 5}, ns=globals()), 1)
```

### Async function calling

``` python
async def asums(a, b): return a + b
ns = mk_ns(asums); ns
```

    {'asums': <function __main__.asums(a, b)>}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L258"
target="_blank" style="float:right; font-size:smaller">source</a>

### call_func_async

``` python

async def call_func_async(
    fc_name, fc_inputs, ns, raise_on_err:bool=True
):

```

*Awaits the function `fc_name` with the given `fc_inputs` using
namespace `ns`.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
async def call_func_async(fc_name, fc_inputs, ns, raise_on_err=True):
    "Awaits the function `fc_name` with the given `fc_inputs` using namespace `ns`."
    if not isinstance(ns, abc.Mapping): ns = mk_ns(ns)
    func = resolve_nm(fc_name, ns)
    try:
        res = call_func(fc_name, fc_inputs, ns, raise_on_err=raise_on_err)
        res = await maybe_await(res)
    except Exception as e:
        if raise_on_err: raise e from None
        else: return traceback.format_exc()
    return res
```

</details>

Testing async
[`call_func_async`](https://AnswerDotAI.github.io/toolslm/funccall.html#call_func_async)
both with sync and async functions. Sync functions are automatically run
in a separate thread via `asyncio.to_thread`, allowing `asyncio.gather`
to execute multiple sync tool calls in parallel without blocking the
event loop.

``` python
test_eq(await call_func_async('asums', {'a': 1, 'b': 2}, ns=[asums]), 3)
```

``` python
test_eq(await call_func_async('sums', {'a': 1, 'b': 2}, ns=[sums]), 3)
```

``` python
r = await call_func_async('asums', {'a': 1, 'b': '2'}, ns=[asums], raise_on_err=False)
assert "unsupported operand type(s) for +: 'int' and 'str'" in r
```

``` python
ex = False
try: await call_func_async('asums', {'a': 1, 'b': '2'}, ns=[asums], raise_on_err=True)
except: ex = True
assert ex
```

``` python
class B:
    async def g(self, x:int): return x*2

b = B()
res = await call_func_async('b.g', {'x': 5}, ns=globals())
test_eq(res, 10)
```

## Schema to function

``` python
type_map = {'string': str, 'boolean': bool, 'integer': int, 'number': float, 'array': list, 'object': dict}
```

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L271"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_param

``` python

def mk_param(
    nm, props, req
):

```

*Create a `Parameter` for `nm` with schema `props`*

``` python
tool = dict2obj({
    'description': 'Find real-…',
    'inputSchema': { '$schema': 'http://json-schema.org/draft-07/schema#',
                   'additionalProperties': False,
                   'properties': { 'language': { 'description': 'Filter by …', 'items': {'type': 'string'}, 'type': 'array'},
                                   'matchCase': {'default': False, 'description': 'Whether th…', 'type': 'boolean'},
                                   'path': {'description': 'Filter by …', 'type': 'string'},
                                   'query': {'description': 'The litera…', 'type': 'string'},
                                   'useRegexp': {'default': False, 'description': 'Whether to…', 'type': 'boolean'}},
                   'required': ['query'], 'type': 'object'},
    'name': 'searchGitHub'
})
```

``` python
props, req = tool.inputSchema['properties'], tool.inputSchema['required']
list(props)
```

    ['language', 'matchCase', 'path', 'query', 'useRegexp']

``` python
props.matchCase
```

``` python
{'default': False, 'description': 'Whether th…', 'type': 'boolean'}
```

``` python
p = mk_param('query', props.query, req)
p, p.kind
```

    (<Parameter "query: str">, <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>)

``` python
p = mk_param('language', props.language, req)
p, p.kind
```

    (<Parameter "language: list[str] = None">, <_ParameterKind.KEYWORD_ONLY: 3>)

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L282"
target="_blank" style="float:right; font-size:smaller">source</a>

### schema2sig

``` python

def schema2sig(
    tool
):

```

*Convert json schema `tool` to a `Signature`*

``` python
schema2sig(tool)
```

    <Signature (query: str, *, language: list[str] = None, matchCase: bool = False, path: str = None, useRegexp: bool = False)>

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L289"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_tool

``` python

def mk_tool(
    dispfn, tool
):

```

*Create a callable function from a JSON schema tool definition*

[`mk_tool`](https://AnswerDotAI.github.io/toolslm/funccall.html#mk_tool)
is the inverse of
[`get_schema`](https://AnswerDotAI.github.io/toolslm/funccall.html#get_schema)
— it creates a callable Python function from a JSON schema tool
definition. This is useful for MCP clients where tools are defined as
schemas but need to be called as regular Python functions.

The created function has a proper signature, docstring, and annotations,
so it works well with IDE autocomplete and introspection.

``` python
def dispatch_eg(name, **kwargs): return f"Called {name} with {kwargs}"

fn = mk_tool(dispatch_eg, tool)
fn('hello', path='src/')
```

    "Called searchGitHub with {'query': 'hello', 'path': 'src/'}"
