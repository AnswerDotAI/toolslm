# funccall source


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

<details open class="code-fold">
<summary>Exported source</summary>

``` python
import inspect
from collections import abc
from fastcore.utils import *
from fastcore.docments import docments
from typing import get_origin, get_args, Dict, List, Optional, Tuple, Union
from types import UnionType
```

</details>

## Function calling

Many LLMs do function calling (aka tool use) by taking advantage of JSON
schema.

We’ll use [docments](https://fastcore.fast.ai/docments.html) to make
getting JSON schema from Python functions as ergonomic as possible. Each
parameter (and the return value) should have a type, and a docments
comment with the description of what it is. Here’s an example:

``` python
def silly_sum(
    a:int, # First thing to sum
    b:int=1, # Second thing to sum
    c:list[int]=None, # A pointless argument
) -> int: # The sum of the inputs
    "Adds a + b."
    return a + b
```

This is what `docments` makes of that:

``` python
d = docments(silly_sum, full=True)
d
```

``` json
{ 'a': { 'anno': <class 'int'>,
         'default': <class 'inspect._empty'>,
         'docment': 'First thing to sum'},
  'b': {'anno': <class 'int'>, 'default': 1, 'docment': 'Second thing to sum'},
  'c': {'anno': list[int], 'default': None, 'docment': 'A pointless argument'},
  'return': { 'anno': <class 'int'>,
              'default': <class 'inspect._empty'>,
              'docment': 'The sum of the inputs'}}
```

Note that this is an
[AttrDict](https://fastcore.fast.ai/basics.html#attrdict) so we can
treat it like an object, *or* a dict:

``` python
d.a.docment, d['a']['anno']
```

    ('First thing to sum', int)

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _types(t:type)->tuple[str,Optional[str]]:
    "Tuple of json schema type name and (if appropriate) array item name."
    if t is empty: raise TypeError('Missing type')
    tmap = {int:"integer", float:"number", str:"string", bool:"boolean", list:"array", dict:"object"}
    tmap.update({k.__name__: v for k, v in tmap.items()})
    if getattr(t, '__origin__', None) in (list,tuple):
        args = getattr(t, '__args__', None)
        item_type = "object" if not args else tmap.get(t.__args__[0].__name__, "object")
        return "array", item_type
    # if t is a string like 'int', directly use the string as the key
    elif isinstance(t, str): return tmap.get(t, "object"), None
    # if t is the type itself and a container
    elif get_origin(t): return tmap.get(get_origin(t).__name__, "object"), None
    # if t is the type itself like int, use the __name__ representation as the key
    else: return tmap.get(t.__name__, "object"), None
```

</details>

This internal function is needed to convert Python types into JSON
schema types.

``` python
_types(list[int]), _types(int), _types('int')
```

    (('array', 'integer'), ('integer', None), ('integer', None))

``` python
_types(List[int]), _types(Optional[str]), _types(str | None), _types(Tuple[str, int])
```

    (('array', 'integer'), ('object', None), ('object', None), ('array', 'string'))

Note the current behavior:

- ignores all but the first argument for tuples
- union types map to object which is a stand-in for arbitrary types

These and other approximations may require further refinement in the
future.

Will also convert custom types to the `object` type.

``` python
class Custom: a: int
_types(list[Custom]), _types(Custom)
```

    (('array', 'object'), ('object', None))

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _param(name, info):
    "json schema parameter given `name` and `info` from docments full dict."
    paramt,itemt = _types(info.anno)
    pschema = dict(type=paramt, description=info.docment or "")
    if itemt: pschema["items"] = {"type": itemt}
    if info.default is not empty: pschema["default"] = info.default
    return pschema
```

</details>

This private function converts a key/value pair from the `docments`
structure into the `dict` that will be needed for the schema.

``` python
n,o = first(d.items())
print(n,'//', o)
_param(n, o)
```

    a // {'docment': 'First thing to sum', 'anno': <class 'int'>, 'default': <class 'inspect._empty'>}

    {'type': 'integer', 'description': 'First thing to sum'}

``` python
_handle_type(int, None), _handle_type(Path, None)
```

    ({'type': 'integer'}, {'type': 'string', 'format': 'Path'})

``` python
assert _is_parameterized(list[int]) == True
assert _is_parameterized(int) == False
assert _is_container(list[int]) == True
assert _is_container(dict[str, int]) == True
assert _is_container(int) == False
```

For union and optional types, `Union` covers older `Union[str]` syntax
while `UnionType` covers 3.10+ `str | None` syntax.

``` python
def _example_new_unioin(opt_tup: str | None):
    pass

d = docments(_example_new_unioin, full=True)
anno1 = first(d.items())[1].anno
(anno1, get_origin(anno1), get_args(anno1))
```

    (str | None, types.UnionType, (str, NoneType))

``` python
def _example_old_union(opt_tup: Union[str, type(None)] =None):
    pass

d = docments(_example_old_union, full=True)
anno2 = first(d.items())[1].anno
(anno2, get_origin(anno2), get_args(anno2))
```

    (typing.Optional[str], typing.Union, (str, NoneType))

Support for both union types is part of the broader container handling:

``` python
# Test primitive types
defs = {}
assert _handle_type(int, defs) == {'type': 'integer'}
assert _handle_type(str, defs) == {'type': 'string'}
assert _handle_type(bool, defs) == {'type': 'boolean'}
assert _handle_type(float, defs) == {'type': 'number'}

# Test custom class
class TestClass:
    def __init__(self, x: int, y: int): store_attr()

result = _handle_type(TestClass, defs)
assert result == {'$ref': '#/$defs/TestClass'}
assert 'TestClass' in defs
assert defs['TestClass']['type'] == 'object'
assert 'properties' in defs['TestClass']
```

``` python
# Test primitive types in containers
assert _handle_container(list, (int,), defs) == {'type': 'array', 'items': {'type': 'integer'}}
assert _handle_container(tuple, (str,), defs) == {'type': 'array', 'items': {'type': 'string'}}
assert _handle_container(set, (str,), defs) == {'type': 'array', 'items': {'type': 'string'}, 'uniqueItems': True}
assert _handle_container(dict, (str,bool), defs) == {'type': 'object', 'additionalProperties': {'type': 'boolean'}}

result = _handle_container(list, (TestClass,), defs)
assert result == {'type': 'array', 'items': {'$ref': '#/$defs/TestClass'}}
assert 'TestClass' in defs

# Test complex nested structure
ComplexType = dict[str, list[TestClass]]
result = _handle_container(dict, (str, list[TestClass]), defs)
assert result == {
    'type': 'object',
    'additionalProperties': {
        'type': 'array',
        'items': {'$ref': '#/$defs/TestClass'}
    }
}
```

``` python
# Test processing of a required integer property
props, req = {}, {}
class TestClass:
    "Test class"
    def __init__(
        self,
        x: int, # First thing
        y: list[float], # Second thing
        z: str = "default", # Third thing
    ): store_attr()

d = docments(TestClass, full=True)
_process_property('x', d.x, props, req, defs)
assert 'x' in props
assert props['x']['type'] == 'integer'
assert 'x' in req

# Test processing of a required list property
_process_property('y', d.y, props, req, defs)
assert 'y' in props
assert props['y']['type'] == 'array'
assert props['y']['items']['type'] == 'number'
assert 'y' in req

# Test processing of an optional string property with default
_process_property('z', d.z, props, req, defs)
assert 'z' in props
assert props['z']['type'] == 'string'
assert props['z']['default'] == "default"
assert 'z' not in req
```

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L118"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_schema

>  get_schema (f:Union[<built-infunctioncallable>,dict],
>                  pname='input_schema')

*Generate JSON schema for a class, function, or method*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def get_schema(f:Union[callable,dict], pname='input_schema')->dict:
    "Generate JSON schema for a class, function, or method"
    if isinstance(f, dict): return f
    schema = _get_nested_schema(f)
    desc = f.__doc__
    assert desc, "Docstring missing!"
    d = docments(f, full=True)
    ret = d.pop('return')
    if ret.anno is not empty: desc += f'\n\nReturns:\n- type: {_types(ret.anno)[0]}'
    return {"name": f.__name__, "description": desc, pname: schema}
```

</details>

Putting this all together, we can now test getting a schema from
`silly_sum`. The tool use spec doesn’t support return annotations
directly, so we put that in the description instead.

``` python
s = get_schema(silly_sum)
desc = s.pop('description')
print(desc)
s
```

    Adds a + b.

    Returns:
    - type: integer

    {'name': 'silly_sum',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'First thing to sum'},
       'b': {'type': 'integer',
        'description': 'Second thing to sum',
        'default': 1},
       'c': {'type': 'array',
        'description': 'A pointless argument',
        'items': {'type': 'integer'},
        'default': None}},
      'title': None,
      'required': ['a']}}

This also works with string annotations, e.g:

``` python
def silly_test(
    a: 'int',  # quoted type hint
):
    "Mandatory docstring"
    return a

get_schema(silly_test)
```

    {'name': 'silly_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'quoted type hint'}},
      'title': None,
      'required': ['a']}}

This also works with instance methods:

``` python
class Dummy:
    def sums(
        self,
        a:int,  # First thing to sum
        b:int=1 # Second thing to sum
    ) -> int: # The sum of the inputs
        "Adds a + b."
        print(f"Finding the sum of {a} and {b}")
        return a + b

get_schema(Dummy.sums)
```

    {'name': 'sums',
     'description': 'Adds a + b.\n\nReturns:\n- type: integer',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'integer', 'description': 'First thing to sum'},
       'b': {'type': 'integer',
        'description': 'Second thing to sum',
        'default': 1}},
      'title': None,
      'required': ['a']}}

[`get_schema`](https://AnswerDotAI.github.io/toolslm/funccall.html#get_schema)
also handles more complicated structures such as nested classes. This is
useful for things like structured outputs.

``` python
class Turn:
    "Turn between two speakers"
    def __init__(
        self,
        speaker_a:str, # First speaker's message
        speaker_b:str,  # Second speaker's message
    ): store_attr()

class Conversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:list[Turn], # Turns of the conversation
    ): store_attr()

get_schema(Conversation)
```

    {'name': 'Conversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'array',
        'description': 'Turns of the conversation',
        'items': {'$ref': '#/$defs/Turn'}}},
      'title': 'Conversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

``` python
class DictConversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:dict[str,list[Turn]], # dictionary of topics and the Turns of the conversation
    ): store_attr()

get_schema(DictConversation)
```

    {'name': 'DictConversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'object',
        'description': 'dictionary of topics and the Turns of the conversation',
        'additionalProperties': {'type': 'array',
         'items': {'$ref': '#/$defs/Turn'}}}},
      'title': 'DictConversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

``` python
class SetConversation:
    "A conversation between two speakers"
    def __init__(
        self,
        turns:set[Turn], # the unique Turns of the conversation
    ): store_attr()

get_schema(SetConversation)
```

    {'name': 'SetConversation',
     'description': 'A conversation between two speakers',
     'input_schema': {'type': 'object',
      'properties': {'turns': {'type': 'array',
        'description': 'the unique Turns of the conversation',
        'items': {'$ref': '#/$defs/Turn'},
        'uniqueItems': True}},
      'title': 'SetConversation',
      'required': ['turns'],
      '$defs': {'Turn': {'type': 'object',
        'properties': {'speaker_a': {'type': 'string',
          'description': "First speaker's message"},
         'speaker_b': {'type': 'string',
          'description': "Second speaker's message"}},
        'title': 'Turn',
        'required': ['speaker_a', 'speaker_b']}}}}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L130"
target="_blank" style="float:right; font-size:smaller">source</a>

### PathArg

>  PathArg (path:str)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td>str</td>
<td>A filesystem path</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def PathArg(
    path: str  # A filesystem path
): return Path(path)
```

</details>

Paths are a special case, since they only take `*args` and `**kwargs` as
params, but normally we’d use them in a schema by just passing a str. So
we create a custom param type for that.

``` python
def path_test(
    a: PathArg,  # a type hint
    b: PathArg   # b type hint
):
    "Mandatory docstring"
    return a/b

get_schema(path_test)
```

    {'name': 'path_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'object',
        'description': 'a type hint',
        '$ref': '#/$defs/PathArg'},
       'b': {'type': 'object',
        'description': 'b type hint',
        '$ref': '#/$defs/PathArg'}},
      'title': None,
      'required': ['a', 'b'],
      '$defs': {'PathArg': {'type': 'object',
        'properties': {'path': {'type': 'string',
          'description': 'A filesystem path'}},
        'title': None,
        'required': ['path']}}}}

Alternatively, use `Path` as usual, and handle the `format` key in the
json to use that as a callable:

``` python
def path_test2(
    a: Path,  # a type hint
    b: Path   # b type hint
):
    "Mandatory docstring"
    return a/b

get_schema(path_test2)
```

    {'name': 'path_test2',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'a': {'type': 'string',
        'description': 'a type hint',
        'format': 'Path'},
       'b': {'type': 'string', 'description': 'b type hint', 'format': 'Path'}},
      'title': None,
      'required': ['a', 'b']}}

### Additional [`get_schema()`](https://AnswerDotAI.github.io/toolslm/funccall.html#get_schema) Test Cases

Union types are approximately mapped to JSON schema ‘anyOf’ with two or
more value types.

``` python
def _union_test(opt_tup: Union[Tuple[int, int], str, int]=None):
    "Mandatory docstring"
    return ""
get_schema(_union_test)
```

    {'name': '_union_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array'}, {'type': 'string'}, {'type': 'integer'}]}},
      'title': None}}

The new (Python 3.10+) union syntax can also be used, producing an
equivalent schema.

``` python
def _new_union_test(opt_tup: Tuple[int, int] | str | int =None):
    "Mandatory docstring"
    pass
get_schema(_new_union_test)
```

    {'name': '_new_union_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array'}, {'type': 'string'}, {'type': 'integer'}]}},
      'title': None}}

Optional is a special case of union types, limited to two types, one of
which is None (mapped to null in JSON schema):

``` python
def _optional_test(opt_tup: Optional[Tuple[int, int]]=None):
    "Mandatory docstring"
    pass
get_schema(_optional_test)
```

    {'name': '_optional_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'opt_tup': {'type': 'object',
        'description': '',
        'default': None,
        'anyOf': [{'type': 'array'}, {'type': 'null'}]}},
      'title': None}}

Containers can also be used, both in their parameterized form
(`List[int]`) or as their unparameterized raw type (`List`). In the
latter case, the item type is mapped to `object` in JSON schema.

``` python
def _list_test(l: List[int]):
    "Mandatory docstring"
    pass
get_schema(_list_test)
```

    {'name': '_list_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'l': {'type': 'array',
        'description': '',
        'items': {'type': 'integer'}}},
      'title': None,
      'required': ['l']}}

``` python
def _raw_list_test(l: List):
    "Mandatory docstring"
    pass
get_schema(_raw_list_test)
```

    {'name': '_raw_list_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'l': {'type': 'array',
        'description': '',
        'items': {'type': 'object'}}},
      'title': None,
      'required': ['l']}}

The same applies to dictionary, which can similarly be parameterized
with key/value types or specified as a raw type.

``` python
def _dict_test(d: Dict[str, int]):
    "Mandatory docstring"
    pass
get_schema(_dict_test)
```

    {'name': '_dict_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'d': {'type': 'object',
        'description': '',
        'additionalProperties': {'type': 'integer'}}},
      'title': None,
      'required': ['d']}}

``` python
def _raw_dict_test(d: Dict):
    "Mandatory docstring"
get_schema(_raw_dict_test)
```

    {'name': '_raw_dict_test',
     'description': 'Mandatory docstring',
     'input_schema': {'type': 'object',
      'properties': {'d': {'type': 'object', 'description': ''}},
      'title': None,
      'required': ['d']}}

### Python tool

In language model clients it’s often useful to have a ‘code interpreter’
– this is something that runs code, and generally outputs the result of
the last expression (i.e like IPython or Jupyter).

In this section we’ll create the
[`python`](https://AnswerDotAI.github.io/toolslm/funccall.html#python)
function, which executes a string as Python code, with an optional
timeout. If the last line is an expression, we’ll return that – just
like in IPython or Jupyter, but without needing them installed.

<details open class="code-fold">
<summary>Exported source</summary>

``` python
import ast, time, signal, traceback
from fastcore.utils import *
```

</details>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _copy_loc(new, orig):
    "Copy location information from original node to new node and all children."
    new = ast.copy_location(new, orig)
    for field, o in ast.iter_fields(new):
        if isinstance(o, ast.AST): setattr(new, field, _copy_loc(o, orig))
        elif isinstance(o, list): setattr(new, field, [_copy_loc(value, orig) for value in o])
    return new
```

</details>

This is an internal function that’s needed for
[`_run`](https://AnswerDotAI.github.io/toolslm/funccall.html#_run) to
ensure that location information is available in the abstract syntax
tree (AST), since otherwise python complains.

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def _run(code:str, glb:dict=None, loc:dict=None):
    "Run `code`, returning final expression (similar to IPython)"
    tree = ast.parse(code)
    last_node = tree.body[-1] if tree.body else None
    
    # If the last node is an expression, modify the AST to capture the result
    if isinstance(last_node, ast.Expr):
        tgt = [ast.Name(id='_result', ctx=ast.Store())]
        assign_node = ast.Assign(targets=tgt, value=last_node.value)
        tree.body[-1] = _copy_loc(assign_node, last_node)

    compiled_code = compile(tree, filename='<ast>', mode='exec')
    glb = glb or {}
    stdout_buffer = io.StringIO()
    saved_stdout = sys.stdout
    sys.stdout = stdout_buffer
    try: exec(compiled_code, glb, loc)
    finally: sys.stdout = saved_stdout
    _result = glb.get('_result', None)
    if _result is not None: return _result
    return stdout_buffer.getvalue().strip()
```

</details>

This is the internal function used to actually run the code – we pull
off the last AST to see if it’s an expression (i.e something that
returns a value), and if so, we store it to a special `_result` variable
so we can return it.

``` python
_run('import math;math.factorial(12)')
```

    479001600

``` python
_run('print(1+1)')
```

    '2'

We now have the machinery needed to create our
[`python`](https://AnswerDotAI.github.io/toolslm/funccall.html#python)
function.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L171"
target="_blank" style="float:right; font-size:smaller">source</a>

### python

>  python (code:str, glb:Optional[dict]=None, loc:Optional[dict]=None,
>              timeout:int=3600)

*Executes python `code` with `timeout` and returning final expression
(similar to IPython).*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>str</td>
<td></td>
<td>Code to execute</td>
</tr>
<tr>
<td>glb</td>
<td>Optional</td>
<td>None</td>
<td>Globals namespace</td>
</tr>
<tr>
<td>loc</td>
<td>Optional</td>
<td>None</td>
<td>Locals namespace</td>
</tr>
<tr>
<td>timeout</td>
<td>int</td>
<td>3600</td>
<td>Maximum run time in seconds</td>
</tr>
</tbody>
</table>

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def python(
    code:str, # Code to execute
    glb:Optional[dict]=None, # Globals namespace
    loc:Optional[dict]=None, # Locals namespace
    timeout:int=3600 # Maximum run time in seconds
):
    "Executes python `code` with `timeout` and returning final expression (similar to IPython)."
    def handler(*args): raise TimeoutError()
    if glb is None: glb = inspect.currentframe().f_back.f_globals
    if loc is None: loc=glb
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(timeout)
    try: return _run(code, glb, loc)
    except Exception as e: return traceback.format_exc()
    finally: signal.alarm(0)
```

</details>

There’s no builtin security here – you should generally use this in a
sandbox, or alternatively prompt before running code. It can handle
multiline function definitions, and pretty much any other normal Python
syntax.

``` python
python("""def factorial(n):
    if n == 0 or n == 1: return 1
    else: return n * factorial(n-1)
factorial(5)""")
```

    120

If the code takes longer than `timeout` then it returns an error string.

``` python
print(python('import time; time.sleep(10)', timeout=1))
```

    Traceback (most recent call last):
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_10039/2052945749.py", line 14, in python
        try: return _run(code, glb, loc)
                    ^^^^^^^^^^^^^^^^^^^^
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_10039/1858893181.py", line 18, in _run
        try: exec(compiled_code, glb, loc)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      File "<ast>", line 1, in <module>
      File "/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_10039/2052945749.py", line 9, in handler
        def handler(*args): raise TimeoutError()
                            ^^^^^^^^^^^^^^^^^^^^
    TimeoutError

By default the caller’s global namespace is used.

``` python
python("a=1")
a
```

    1

Pass a different `glb` if needed; this requires using `python_ns`.

``` python
glb = {}
python("a=3", glb=glb)
a, glb['a']
```

    (1, 3)

``` python
get_schema(python)
```

    {'name': 'python',
     'description': 'Executes python `code` with `timeout` and returning final expression (similar to IPython).',
     'input_schema': {'type': 'object',
      'properties': {'code': {'type': 'string', 'description': 'Code to execute'},
       'glb': {'type': 'object',
        'description': 'Globals namespace',
        'default': None,
        'anyOf': [{'type': 'object'}, {'type': 'null'}]},
       'loc': {'type': 'object',
        'description': 'Locals namespace',
        'default': None,
        'anyOf': [{'type': 'object'}, {'type': 'null'}]},
       'timeout': {'type': 'integer',
        'description': 'Maximum run time in seconds',
        'default': 3600}},
      'title': None,
      'required': ['code']}}

### Tool Calling

Many LLM API providers offer tool calling where an LLM can choose to
call a given tool. This is also helpful for structured outputs since the
response from the LLM is contrained to the required arguments of the
tool.

This section will be dedicated to helper functions for calling tools. We
don’t want to allow LLMs to call just any possible function (that would
be a security disaster!) so we create a namespace – that is, a
dictionary of allowable function names to call.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L188"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_ns

>  mk_ns (fs)

``` python
def sums(a, b): return a + b
ns = mk_ns(sums); ns
```

    {'sums': <function __main__.sums(a, b)>}

``` python
ns['sums'](1, 2)
```

    3

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L197"
target="_blank" style="float:right; font-size:smaller">source</a>

### call_func

>  call_func (fc_name, fc_inputs, ns, raise_on_err=True)

*Call the function `fc_name` with the given `fc_inputs` using namespace
`ns`.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
def call_func(fc_name, fc_inputs, ns, raise_on_err=True):
    "Call the function `fc_name` with the given `fc_inputs` using namespace `ns`."
    if not isinstance(ns, abc.Mapping): ns = mk_ns(ns)
    func = ns[fc_name]
    # Clean up bad param names
    inps = {re.sub(r'\W', '', k):v for k,v in fc_inputs.items()}
    try: return func(**fc_inputs)
    except Exception as e:
        if raise_on_err: raise e from None
        else: return traceback.format_exc()
```

</details>

Now when we an LLM responses with the tool to use and its inputs, we can
simply use the same namespace it was given to look up the tool and call
it.

``` python
call_func('sums', {'a': 1, 'b': 2}, ns=[sums])
```

    3

``` python
assert "unsupported operand type(s) for +: 'int' and 'str'" in call_func('sums', {'a': 1, 'b': '3'}, ns=ns, raise_on_err=False)
```

``` python
test_fail(call_func, args=['sums', {'a': 1, 'b': '3'}], kwargs={'ns': ns})
```

### Async function calling

``` python
async def asums(a, b): return a + b
ns = mk_ns(asums); ns
```

    {'asums': <function __main__.asums(a, b)>}

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/toolslm/blob/main/toolslm/funccall.py#L209"
target="_blank" style="float:right; font-size:smaller">source</a>

### call_func_async

>  call_func_async (fc_name, fc_inputs, ns, raise_on_err=True)

*Awaits the function `fc_name` with the given `fc_inputs` using
namespace `ns`.*

<details open class="code-fold">
<summary>Exported source</summary>

``` python
async def call_func_async(fc_name, fc_inputs, ns, raise_on_err=True):
    "Awaits the function `fc_name` with the given `fc_inputs` using namespace `ns`."
    res = call_func(fc_name, fc_inputs, ns, raise_on_err=raise_on_err)
    if inspect.iscoroutine(res):
        try: res = await res
        except Exception as e:
            if raise_on_err: raise e from None
            else: return traceback.format_exc()
    return res
```

</details>

``` python
await call_func_async('asums', {'a': 1, 'b': 2}, ns=[asums])
```

    3

``` python
r = await call_func_async('asums', {'a': 1, 'b': '2'}, ns=[asums], raise_on_err=False)
assert "unsupported operand type(s) for +: 'int' and 'str'" in r
```

``` python
ex = False
try: await call_func_async('asums', {'a': 1, 'b': '2'}, ns=[asums], raise_on_err=True)
except: ex = True
assert ex
```
