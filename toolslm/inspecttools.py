"""LLM tools for inspecting the symbol table and importing modules"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../05_inspecttools.ipynb.

# %% auto #0
__all__ = ['importmodule', 'SymbolNotFound', 'resolve', 'symsrc', 'symtype', 'symval', 'symtype_val', 'symdir', 'symnth',
           'symlen', 'symslice', 'symsearch', 'symset', 'symfiles_folder', 'symfiles_package']

# %% ../05_inspecttools.ipynb #5ae7ad05
from fastcore.utils import *
from fastcore.meta import delegates
import inspect, re, sys, ast, builtins, os, linecache
from importlib import import_module
from .xml import *

# %% ../05_inspecttools.ipynb #9778fca8
def _find_frame_dict(var:str):
    "Find the dict (globals or locals) containing var"
    frame = inspect.currentframe().f_back
    while frame:
        if var in frame.f_globals: return frame.f_globals
        frame = frame.f_back
    raise ValueError(f"Could not find {var} in any scope")

# %% ../05_inspecttools.ipynb #7fd415fa
def importmodule(
    mod: str, # The module to import (e.g. 'torch.nn.functional')
    caller_symbol:str = '__msg_id'  # The name of the special variable to find the correct caller namespace
):
    """Import a module into the caller's global namespace so it's available for `symsrc`, `symval`, `symdir`, etc.
    Use this before inspecting or using symbols from modules not yet imported."""
    g = _find_frame_dict(caller_symbol)
    import_module(mod)
    g[mod.split('.')[0]] = import_module(mod.split('.')[0])

# %% ../05_inspecttools.ipynb #e40f68c9
class SymbolNotFound(Exception):
    def __repr__(self): return f"SymbolNotFound({self.args[0]})"
    __str__ = __repr__

_last = None

def resolve(
    sym: str  # Dotted symbol path, with optional [n] indexing, e.g. "module.attr.subattr[1]" or "_last" for previous result
):
    """Resolve a dotted symbol string to its Python object, with optional [n] indexing.
    Sets global `_last` to the resolved object for chaining.
    Pass `"_last"` to reference the result of the previous tool call.

    Examples:

    - `resolve("sympy.sets.sets.Interval")` -> `<class 'sympy.sets.sets.Interval'>`
    - `resolve("mylist[2]")` -> third element of mylist"""
    global _last
    if (sym := sym.strip()) == '_last': return _last
    g = _find_frame_dict('__msg_id')
    if match := re.match(r'^(\w+)\[(\d+)\]$', sym):
        attr, idx = match.groups()
        parts, _last = ['_last'], _last[int(idx)] if attr == '_last' else g[attr][int(idx)]
    else: parts = re.split(r'\.(?![^\[]*\])', sym)
    try: obj = _last if parts[0] == '_last' else g[parts[0]]
    except KeyError: raise SymbolNotFound(f"Symbol '{parts[0]}' not found. Consider using `importmodule` first.")
    for part in parts[1:]:
        match = re.match(r'(\w+)\[(\d+)\]$', part)
        if match:
            attr, idx = match.groups()
            obj = getattr(obj, attr)[int(idx)]
        else: obj = getattr(obj, part)
    _last = obj
    return obj

# %% ../05_inspecttools.ipynb #659bf879
def _src_from_lines(lines, start):
    "Extract a single definition from lines starting at start (0-indexed)"
    src = ''.join(lines[start:])
    try: tree = ast.parse(src)
    except SyntaxError: return None
    if not tree.body: return None
    return ''.join(lines[start:start + tree.body[0].end_lineno])

# %% ../05_inspecttools.ipynb #41ecbd5c
def symsrc(
    sym: str  # Dotted symbol path (e.g `Interval` or `sympy.sets.sets.Interval`) or "_last" for previous result
):
    """Get the source code for a symbol.

    Examples:

    - `symsrc("Interval")` -> source code of Interval class if it's already imported
    - `symsrc("sympy.sets.sets.Interval")` -> source code of Interval class
    - `symsrc("_last")` -> source of object from previous tool call
    - For dispatchers or registries of callables: `symnth("module.dispatcher.funcs", n) then symsrc("_last")`"""
    try: obj = resolve(sym)
    except SymbolNotFound as e: return str(e)
    if isinstance(obj, type) or callable(obj): pass
    elif hasattr(obj, '__module__') and not inspect.ismodule(obj): obj = obj.__class__
    try: fname = inspect.getfile(obj)
    except (OSError, TypeError): fname = "<session>"
    try: return f"File: {fname}\n\n{inspect.getsource(obj)}"
    except (OSError, TypeError): pass
    name = getattr(obj, '__name__', None)
    if not name: raise OSError(f"Cannot get source for {sym}")
    pat = rf'^(class|def)\s+{name}\b'
    for fname, (_, _, lines, _) in linecache.cache.items():
        src = ''.join(lines)
        if match := re.search(pat, src, re.MULTILINE):
            start = src[:match.start()].count('\n')
            if extracted := _src_from_lines(lines, start): return f"File: {fname}\n\n{extracted}"
    raise OSError(f"Source for {name} not found")

# %% ../05_inspecttools.ipynb #bbf67405
def symtype(
    syms: str  # Comma separated str list of dotted symbol paths (e.g `'Interval,a'` or `'sympy.sets.sets.Interval'`); "_last" for prev result
):
    """Get the type of a symbol and set `_last`.

    Examples:

    - `symtype("sympy.sets.sets.Interval")` -> `<class 'type'>`
    - `symtype("doesnotexist")` -> `'SymbolNotFound`
    - `symtype("_last")` -> type of previous result"""
    def f(o):
        try: return type(resolve(o))
        except SymbolNotFound as e: return str(e)
    return [f(o) for o in re.split(r'\,\s*', syms)]

# %% ../05_inspecttools.ipynb #dd4279b8
def symval(
    syms: str  # Comma separated str list of dotted symbol paths (e.g `Interval` or `sympy.sets.sets.Interval`); "_last" for prev result
):
    """List of repr of symbols' values.

    Examples:
    
    - `symval("sympy.sets.sets.Interval")` -> `[<class 'sympy.sets.sets.Interval'>]`
    - `symval("some_dict.keys")` -> `[dict_keys([...])]`
    - `symval("a,notexist")` -> `['foo','SymbolNotFound']`"""
    def f(o):
        try: return repr(resolve(o))
        except SymbolNotFound as e: return str(e)
    return [f(o) for o in re.split(r'\,\s*', syms)]

# %% ../05_inspecttools.ipynb #3cb05b78
def symtype_val(
    syms: str  # Comma separated str list of dotted symbol paths (e.g `Interval` or `sympy.sets.sets.Interval`); "_last" for prev result
):
    """List of 2-ple of (type,repr) of symbols' values.

    Examples:
    
    - `symtype_val("a,c,notexist")` -> `[(<class 'str'>,'foo'),(<class 'int'>,1), 'SymbolNotFound']`"""
    def f(o):
        try: r = resolve(o)
        except SymbolNotFound as e: return 'SymbolNotFound'
        return (type(r), repr(r))
    return [f(o) for o in re.split(r'\,\s*', syms)]

# %% ../05_inspecttools.ipynb #1cd34596
def symdir(
    sym: str,  # Dotted symbol path (e.g `Interval` or `sympy.sets.sets.Interval`) or "_last" for previous result
    exclude_private: bool=False # Filter out attrs starting with "_"
):
    """Get dir() listing of a symbol's attributes and set `_last`. E.g: `symdir("sympy.Interval")` -> `['__add__', '__and__', ...]`"""
    res = dir(resolve(sym))
    if not exclude_private: return res
    return [o for o in res if o[0]!='_']

# %% ../05_inspecttools.ipynb #9542de0b
def symnth(
    sym: str,  # Dotted symbol path to a dict or object with .values()
    n: int     # Index into the values (0-based)
):
    """Get the nth value from a dict (or any object with .values()). Sets `_last` so you can chain with `symsrc("_last")` etc.

    Examples:
    
    - `symnth("dispatcher.funcs", 12)` -> 13th registered function
    - `symnth("dispatcher.funcs", 0); symsrc("_last")` -> source of first handler"""
    global _last
    _last = list(resolve(sym).values())[n]
    return _last

# %% ../05_inspecttools.ipynb #4ac6ca2d
def symlen(
    sym: str  # Dotted symbol path or "_last" for previous result
):
    "Returns the length of the given symbol"
    return len(resolve(sym))

# %% ../05_inspecttools.ipynb #a5dfbe8f
def symslice(
    sym: str,   # Dotted symbol path or "_last" for previous result
    start: int, # Starting index for slice
    end: int    # Ending index for slice
):
    "Returns the contents of the symbol from the given start to the end."
    try: return resolve(sym)[start:end]
    except Exception as e: return f'Error: {e}'

# %% ../05_inspecttools.ipynb #5fca4d70
def symsearch(
    sym:str,      # Dotted symbol path or "_last" for previous result
    term:str,     # Search term (exact string or regex pattern)
    regex:bool=True,  # If True, regex search; if False, exact match
    flags:int=0   # Regex flags (e.g., re.IGNORECASE)
):
    """Search contents of symbol, which is assumed to be str for regex, or iterable for non-regex.
    Regex mode returns (match, start, end) tuples; otherwise returns (item, index) tuples"""
    if regex: return str([(m.group(), m.start(), m.end()) for m in re.finditer(term, resolve(sym), flags)])
    else: return str([(x, i) for i, x in enumerate(resolve(sym)) if x == term])

# %% ../05_inspecttools.ipynb #02c09e1a
def symset(
    val: str  # Value to assign to _ai_sym
):
    "Set _ai_sym to the given value"
    _find_frame_dict('__msg_id')['_ai_sym'] = val

# %% ../05_inspecttools.ipynb #72e5f0a8
@delegates(sym2folderctx)
def symfiles_folder(
    sym:str,      # Dotted symbol path or "_last" for previous result
    **kwargs
):
    "Return XML context of files in the folder containing `sym`'s definition"
    try: s = resolve(sym)
    except SymbolNotFound as e: return str(e)
    return sym2folderctx(s, **kwargs)

# %% ../05_inspecttools.ipynb #fdd0990e
@delegates(sym2pkgctx)
def symfiles_package(
    sym:str,      # Dotted symbol path or "_last" for previous result
    **kwargs
):
    "Return XML context of all files in `sym`'s top-level package"
    try: s = resolve(sym)
    except SymbolNotFound as e: return str(e)
    return sym2pkgctx(s, **kwargs)
