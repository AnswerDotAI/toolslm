# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_shell.ipynb.

# %% auto 0
__all__ = ['get_shell']

# %% ../02_shell.ipynb
import ast, time, signal, traceback
from fastcore.utils import *

# %% ../02_shell.ipynb
from IPython.terminal.interactiveshell import TerminalInteractiveShell
from IPython.utils.capture import capture_output

# %% ../02_shell.ipynb
TerminalInteractiveShell.orig_run = TerminalInteractiveShell.run_cell

# %% ../02_shell.ipynb
@patch
def run_cell(self:TerminalInteractiveShell, cell, timeout=None, max_memory_mb=None):
    "Wrapper for original `run_cell` which adds timeout, memory limit, and output capture"
    if max_memory_mb:
        orig_limit = resource.getrlimit(resource.RLIMIT_AS)
        max_bytes = max_memory_mb * 1024 * 1024
        resource.setrlimit(resource.RLIMIT_AS, (max_bytes, orig_limit[1]))
    if timeout:
        def handler(*args): raise TimeoutError()
        signal.signal(signal.SIGALRM, handler)
        signal.alarm(timeout)
    try:
        with capture_output() as io: result = self.orig_run(cell)
        result.stdout = io.stdout
        result.outputs = io.outputs
        return result
    except (TimeoutException, MemoryError) as e:
        result = self.ExecutionResult(error_before_exec=None, error_in_exec=e)
    except MemoryError as e:
        result = self.ExecutionResult(error_before_exec=None, error_in_exec=e)
    finally:
        if timeout: signal.alarm(0)
        if max_memory_mb: resource.setrlimit(resource.RLIMIT_AS, orig_limit)

# %% ../02_shell.ipynb
def get_shell()->TerminalInteractiveShell:
    "Get a `TerminalInteractiveShell` with minimal functionality"
    sh = TerminalInteractiveShell()
    sh.logger.log_output = sh.history_manager.enabled = False
    dh = sh.displayhook
    dh.finish_displayhook = dh.write_output_prompt = dh.start_displayhook = lambda: None
    dh.write_format_data = lambda format_dict, md_dict=None: None
    sh.logstart = sh.automagic = sh.autoindent = False
    sh.autocall = 0
    sh.system = lambda cmd: None
    return sh
