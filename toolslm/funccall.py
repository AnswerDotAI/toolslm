# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_funccall.ipynb.

# %% auto 0
__all__ = ['empty', 'custom_types', 'get_schema', 'python', 'mk_ns', 'call_func', 'call_func_async', 'mk_param', 'schema2sig',
           'mk_tool']

# %% ../01_funccall.ipynb
import inspect, json, ast
from collections import abc
from fastcore.utils import *
from fastcore.docments import docments
from typing import get_origin, get_args, Dict, List, Optional, Tuple, Union, Any
from types import UnionType
from typing import get_type_hints
from inspect import Parameter, Signature
from decimal import Decimal
from uuid import UUID

# %% ../01_funccall.ipynb
empty = inspect.Parameter.empty

# %% ../01_funccall.ipynb
def _types(t:type)->tuple[str,Optional[str]]:
    "Tuple of json schema type name and (if appropriate) array item name."
    if t is empty: raise TypeError('Missing type')
    tmap = {int:"integer", float:"number", str:"string", bool:"boolean", list:"array", dict:"object"}
    tmap.update({k.__name__: v for k, v in tmap.items()})
    if getattr(t, '__origin__', None) in (list,tuple):
        args = getattr(t, '__args__', None)
        item_type = "object" if not args else tmap.get(t.__args__[0].__name__, "object")
        return "array", item_type
    # if t is a string like 'int', directly use the string as the key
    elif isinstance(t, str): return tmap.get(t, "object"), None
    # if t is the type itself and a container
    elif get_origin(t): return tmap.get(get_origin(t).__name__, "object"), None
    # if t is the type itself like int, use the __name__ representation as the key
    else: return tmap.get(t.__name__, "object"), None

# %% ../01_funccall.ipynb
def _param(
    name, # param name
    info, # dict from docments
    evalable=False): # stringify defaults that can't be literal_eval'd?
    "json schema parameter given `name` and `info` from docments full dict"
    paramt,itemt = _types(info.anno)
    pschema = dict(type=paramt, description=info.docment or "")
    if itemt: pschema["items"] = {"type": itemt}
    if info.default is not empty:
        if evalable:
            try: ast.literal_eval(repr(info.default))
            except: pschema["default"] = str(info.default)
            else: pschema["default"] = info.default
        else: pschema["default"] = info.default
    return pschema

# %% ../01_funccall.ipynb
custom_types = {Path, bytes, Decimal, UUID}

def _handle_type(t, defs):
    "Handle a single type, creating nested schemas if necessary"
    if t is NoneType: return {'type': 'null'}
    if t in custom_types: return {'type':'string', 'format':t.__name__}
    if t in (dict, list, tuple, set): return {'type': _types(t)[0]}
    if isinstance(t, type) and not issubclass(t, (int, float, str, bool)) or inspect.isfunction(t):
        defs[t.__name__] = _get_nested_schema(t)
        return {'$ref': f'#/$defs/{t.__name__}'}
    return {'type': _types(t)[0]}

# %% ../01_funccall.ipynb
def _is_container(t):
    "Check if type is a container (list, dict, tuple, set, Union)"
    origin = get_origin(t)
    return origin in (list, dict, tuple, set, Union) if origin else False

def _is_parameterized(t):
    "Check if type has arguments (e.g. list[int] vs list, dict[str, int] vs dict)"
    return _is_container(t) and (get_args(t) != ())

# %% ../01_funccall.ipynb
def _handle_container(origin, args, defs):
    "Handle container types like dict, list, tuple, set, and Union"
    if origin is Union or origin is UnionType:
        return {"anyOf": [_handle_type(arg, defs) for arg in args]}
    if origin is dict:
        value_type = args[1].__args__[0] if hasattr(args[1], '__args__') else args[1]
        return {
            'type': 'object',
            'additionalProperties': (
                {'type': 'array', 'items': _handle_type(value_type, defs)}
                if hasattr(args[1], '__origin__') else _handle_type(args[1], defs)
            )
        }
    elif origin in (list, tuple, set):
        schema = {'type': 'array', 'items': _handle_type(args[0], defs)}
        if origin is set:
            schema['uniqueItems'] = True
        return schema
    return None

# %% ../01_funccall.ipynb
def _process_property(name, obj, props, req, defs, evalable=False):
    "Process a single property of the schema"
    p = _param(name, obj, evalable=evalable)
    props[name] = p
    if obj.default is empty: req[name] = True

    if _is_container(obj.anno) and _is_parameterized(obj.anno):
        p.update(_handle_container(get_origin(obj.anno), get_args(obj.anno), defs))        
    else:
        # Non-container type or container without arguments
        p.update(_handle_type(obj.anno, defs))

# %% ../01_funccall.ipynb
def _get_nested_schema(obj, evalable=False, skip_hidden=False):
    "Generate nested JSON schema for a class or function"
    d = docments(obj, full=True)
    props, req, defs = {}, {}, {}

    for n, o in d.items():
        if n != 'return' and n != 'self' and not (skip_hidden and n.startswith('_')):
            _process_property(n, o, props, req, defs, evalable=evalable)

    tkw = {}
    if isinstance(obj, type): tkw['title']=obj.__name__
    schema = dict(type='object', properties=props, **tkw)
    if req: schema['required'] = list(req)
    if defs: schema['$defs'] = defs
    return schema

# %% ../01_funccall.ipynb
def get_schema(
    f:Union[callable,dict], # Function to get schema for
    pname='input_schema',   # Key name for parameters
    evalable=False,  # stringify defaults that can't be literal_eval'd?
    skip_hidden=False # skip parameters starting with '_'?
)->dict: # {'name':..., 'description':..., pname:...}
    "Generate JSON schema for a class, function, or method"
    if isinstance(f, dict): return f
    schema = _get_nested_schema(f, evalable=evalable, skip_hidden=skip_hidden)
    desc = f.__doc__
    assert desc, "Docstring missing!"
    d = docments(f, full=True)
    ret = d.pop('return')
    if (ret.anno is not empty) and (ret.anno is not None): desc += f'\n\nReturns:\n- type: {_types(ret.anno)[0]}'
    return {"name": f.__name__, "description": desc, pname: schema}

# %% ../01_funccall.ipynb
import ast, time, signal, traceback
from fastcore.utils import *

# %% ../01_funccall.ipynb
def _copy_loc(new, orig):
    "Copy location information from original node to new node and all children."
    new = ast.copy_location(new, orig)
    for field, o in ast.iter_fields(new):
        if isinstance(o, ast.AST): setattr(new, field, _copy_loc(o, orig))
        elif isinstance(o, list): setattr(new, field, [_copy_loc(value, orig) for value in o])
    return new

# %% ../01_funccall.ipynb
def _run(code:str, glb:dict=None, loc:dict=None):
    "Run `code`, returning final expression (similar to IPython)"
    tree = ast.parse(code)
    last_node = tree.body[-1] if tree.body else None
    
    # If the last node is an expression, modify the AST to capture the result
    if isinstance(last_node, ast.Expr):
        tgt = [ast.Name(id='_result', ctx=ast.Store())]
        assign_node = ast.Assign(targets=tgt, value=last_node.value)
        tree.body[-1] = _copy_loc(assign_node, last_node)

    compiled_code = compile(tree, filename='<ast>', mode='exec')
    glb = glb or {}
    stdout_buffer = io.StringIO()
    saved_stdout = sys.stdout
    sys.stdout = stdout_buffer
    try: exec(compiled_code, glb, loc)
    finally: sys.stdout = saved_stdout
    _result = glb.get('_result', None)
    if _result is not None: return _result
    return stdout_buffer.getvalue().strip()

# %% ../01_funccall.ipynb
def python(
    code:str, # Code to execute
    glb:Optional[dict]=None, # Globals namespace
    loc:Optional[dict]=None, # Locals namespace
    timeout:int=3600 # Maximum run time in seconds
):
    "Executes python `code` with `timeout` and returning final expression (similar to IPython)."
    def handler(*args): raise TimeoutError()
    if glb is None: glb = inspect.currentframe().f_back.f_globals
    if loc is None: loc=glb
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(timeout)
    try: return _run(code, glb, loc)
    except Exception as e: return traceback.format_exc()
    finally: signal.alarm(0)

# %% ../01_funccall.ipynb
def mk_ns(fs):
    if isinstance(fs, abc.Mapping): return fs
    merged = {}
    for o in listify(fs):
        if isinstance(o, dict): merged |= o
        elif callable(o) and hasattr(o, '__name__'): merged |= {o.__name__: o}
    return merged

# %% ../01_funccall.ipynb
def _coerce_inputs(func, inputs):
    "Coerce inputs based on function type annotations"
    hints = get_type_hints(func) if hasattr(func, '__annotations__') else {}
    res = {}
    for k,v in inputs.items():
        ann = hints.get(k)
        if ann in custom_types: res[k] = ann(v)
        elif isinstance(v, dict) and callable(ann): res[k] = ann(**v)
        else: res[k] = v
    return res

# %% ../01_funccall.ipynb
def call_func(fc_name, fc_inputs, ns, raise_on_err=True):
    "Call the function `fc_name` with the given `fc_inputs` using namespace `ns`."
    if not isinstance(ns, abc.Mapping): ns = mk_ns(ns)
    func = ns[fc_name]
    inps = {re.sub(r'\W', '', k):v for k,v in fc_inputs.items()}
    inps = _coerce_inputs(func, inps)
    try: return func(**inps)
    except Exception as e:
        if raise_on_err: raise e from None
        else: return traceback.format_exc()

# %% ../01_funccall.ipynb
async def call_func_async(fc_name, fc_inputs, ns, raise_on_err=True):
    "Awaits the function `fc_name` with the given `fc_inputs` using namespace `ns`."
    res = call_func(fc_name, fc_inputs, ns, raise_on_err=raise_on_err)
    if inspect.iscoroutine(res):
        try: res = await res
        except Exception as e:
            if raise_on_err: raise e from None
            else: return traceback.format_exc()
    return res

# %% ../01_funccall.ipynb
def mk_param(nm, props, req):
    "Create a `Parameter` for `nm` with schema `props`"
    kind = Parameter.POSITIONAL_OR_KEYWORD if nm in req else Parameter.KEYWORD_ONLY
    default = Parameter.empty if nm in req else props.get('default')    
    if props.get('type') == 'array' and 'items' in props:
        item_type = type_map.get(props['items'].get('type'), Any)
        anno = list[item_type]
    else: anno = type_map.get(props.get('type'), Any)
    return Parameter(nm, kind, default=default, annotation=anno)

# %% ../01_funccall.ipynb
def schema2sig(tool):
    "Convert json schema `tool` to a `Signature`"
    props, req = tool.inputSchema['properties'], tool.inputSchema.get('required', [])
    params = sorted([mk_param(k, v, req) for k, v in props.items()], key=lambda p: p.kind)
    return Signature(params)

# %% ../01_funccall.ipynb
def mk_tool(dispfn, tool):
    "Create a callable function from a JSON schema tool definition"
    sig = schema2sig(tool)
    props = tool.inputSchema['properties']
    def fn(*args, **kwargs):
        bound = sig.bind(*args, **kwargs)
        return dispfn(tool.name, **bound.arguments)
    fn.__doc__ = tool.description
    fn.__signature__ = sig
    fn.__name__ = fn.__qualname__ = tool.name
    fn.__annotations__ = {k: p.annotation for k, p in sig.parameters.items()}
    return fn
